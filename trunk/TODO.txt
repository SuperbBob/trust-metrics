
Here's a bunch of stuff to do.


Documentation
=============

Write a lot of documentation, especially for getting started with the
system after you download the code.

- epydoc
- pylint
- comments for every module, class, method and function
- more examples/*.py



Dataset module
==============

* functions for reading and writing GraphML, GMML and Pajek

* modularize the dataset class depending on whether a certain dataset
  is directed or undirected, weighted or unweighted, (sparse or not
  sparse)

  * or it could be that "directed dataset" has a method
    computeReciprocation while undirected don't

  * or it could be that "directed dataset" has a method
    getLargestStronglyConnectedComponent while undirected doesn't
    (strongly connected components take into account directions of
    edges and it is computable only for directed datasets)

One possibility could be to design a bunch of superclasses and make
different datasets inherit from them, such as

                               Dataset
                                  |
       ---------------------------+------------------------------+----------------------------------+
       |                          |                              |
                                  |
 DirectedNetwork          UndirectedNetwork
WeightedNetwork            UnweightedNetwork

AdvogatoNetwork might be a subclass of DirectedNetwork AND of
WeightedNetwork, so that it inherits automatically all their methods.

Maybe even what is now PredGraph can be a subclass of Dataset, such as
DatasetWithPrediction.

Or feel free to come up with a different solution, of course!


NetworkX already has networkx.Graph, networkx.DiGraph and
networkx.XDiGraph (which are subsequent subclasses). In trustlet we
simply subclass XDiGraph. Kasper doesn't think it's necessary to
distinguish at this point. It's always possible to raise an error if a
certain method _really_ needs weighted and/or directed edges.



- object.info():
  - at least all the methods that corresponds to characteristics of the
    dataset as shown in papers by Newman:
  - check powerlaw exponent, examples/powerlaw_test.py
  - please add more...


- PredGraph

  - in case of only some edges predicted (ratio): add all original
    values and mark edges NOT_PREDICTED (find good name, wrt UNDEFINED)


- Trust metrics code

  - check if structure is consistent and refactor, 

    for example there is a better way of dealing with leave-one-out
    thing?  Should it be a different class such as
    TrustMetricEvaluation?  Which methods should the class TrustMetric
    export?

  - correct code for trust metrics, try to make it more efficient,

  - write comments about them


Advogato
========

About the Advogato trust metric.

# understand code of pymmetry for advogato trust metric

# understand how to use code of pymmetry

# integrate code for advogato from pymmetry into the trustlet
  advogatoTM (both local and global) in a clever and correct way, so
  that people who read the code of trustlet don't have to know about
  certificates and how they are used in pymmetry

# implement more trust metrics such as TidalTrust or AppleSeed (find
  description in th relevant paper).


Visualization
=============

Draft out at least the structure for the part of code that deals with
visualization of datasets (and of trust metrics on datasets).  Think
about the structure of the classes, the methods and write some example
methods.



Tables
======

As we have seen writing the paper, it is very important to be able to
easily and quickly generate the tables of results that you need, when
you need it.  This means being able to call methods such as

predGraph.getPredictionTable(rows=[array of trust
metrics],columns=[array of evaluation measures],multiplicity=array of
conditions on edges,precision=number_of_decimals)
that will generate for example
%% Condition=controversial_edges(0.3,0.5)     number of edges= 2367
                 |  fraction wrong predictions  |         MAE
 |        RMSE           |    Coverage   | #edgeswithprediction
AdvogatoLocal     |    0.343423                  |  0.11134342
 |  0.322343423          |     1.00      | 2367
AlwaysMaster      |    0.343423                  |  0.11134342
 |  0.322343423          |     0.50      | 1186
Ebay              |    0.887 555                 |  0.11134342
 |  0.322343423          |     1.00      | 2367
Moletrust3_0.4    |    0.343444                  |  0.11134342
 |  0.322343423          |     1.00      | 2367
%% Condition=every_edge()                     number of edges= 51344
                 |  fraction wrong predictions  |         MAE
 |        RMSE           |    Coverage   | #edgeswithprediction
AdvogatoLocal     |    0.343423                  |  0.11134342
 |  0.322343423          |     1.00      | 51344
AlwaysMaster      |    0.343423                  |  0.11134342
 |  0.322343423          |     0.84      | 50222
Ebay              |    0.887 555                 |  0.11134342
 |  0.322343423          |     1.00      | 51344
Moletrust3_0.4    |    0.343444                  |  0.11134342
 |  0.322343423          |     1.00      | 51344

OR

predGraph.getPredictionTable(rows=[array of conditions],columns=[array
of trust metrics],multiplicity=[array of evaluation
measures],precision=number_of_decimals)
that will generate for example
%% Evaluation measure=MAE
                             |  AdvogatoLocal               | Ebay
             |     Moletrust3_0.5
Controversial_edge(0.3,0.5)   |    0.343423                  |
0.11134342           |  0.322343423
every_edge                    |    0.343423                  |
0.11134342           |  0.322343423
edge_to_connected_node(30)    |    0.343423                  |
0.11134342           |  0.322343423
%% Evaluation measure=Coverage
                             |  AdvogatoLocal               | Ebay
             |     Moletrust3_0.5
Controversial_edge(0.3,0.5)   |    0.933423                  |
0.11134342           |  0.322343423
every_edge                    |    0.343423                  |
0.11134342           |  0.322343423
edge_to_connected_node(30)    |    0.343423                  |
0.11134342           |  0.322343423


Also think about different ways of exporting it (directly into a more
portable format?) (with fix width for columns? or with columns that
accomodate everything? as parameter, ...)
First, think about the methods and how we need them (and for what),
then implement them.



