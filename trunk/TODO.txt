

List of stuff todo:

== Documentation ==

Write a lot of documentation, especially for getting started with the
system after you download the code.

# How to write the first simple program?
# Example code for doing very simple stuff at the beginning (these
  things can be placed also on the wiki of course but first of all in
  the code as well)
# Write textual comments on every single method


== Dataset classes ==

Classes containing the database should be rethought from scratch.

- think functionalities for importing from different formats (readDot,
readGMML, readPajek, ...)  exporting to different formats (writeDot,
writeGMML, writePajek, ...)

- the reading of file should be according to a certain pattern (feel
free to propose one) that depends on the file system structure on
trustlet.org

such as http://www.trustlet.org/datasets/advogato/

Example file that should be read by a constructor at
http://www.trustlet.org/datasets/advogato/advogato-graph-2007-10-21.dot
Constructor might ask the date of the file to be loaded (all
references should be moved from

See more at http://www.trustlet.org/datasets/

- modularize the database class depending on whether a certain
dataset is directed or undirected, weighted or unweighted, (sparse or
not sparse)
-- for example it could be that "weighted dataset" has a method
getReciprocationMatrix (like in the paper), while unweighted don't
have such a method.
-- or it could be that "directed dataset" has a method
computeReciprocation while undirected don't
-- or it could be that "directed dataset" has a method
getLargestStronglyConnectedComponent while undirected don't (Strongly
Conn comp take into account directions of edges and it is computable
only for directed datasets)
One possibility could be to design a bunch of superclasses and make
different datasets inherit from them, such as
                               Dataset
                                  |
       ---------------------------+------------------------------+----------------------------------+
       |                          |                              |
                                  |
 DirectedNetwork          UndirectedNetwork
WeightedNetwork            UnweightedNetwork

AdvogatoNetwork might be a subclass of DirectedNetwork AND of
WeightedNetwork, so that it inherits automatically all their methods.

Maybe even what is now PredGraph can be a subclass of Dataset, such as
DatasetWithPrediction.

Or feel free to come up with a different solution, of course!


# Define a large bunch of methods for the database class, for example
computeReciprocity ...
and at least all the methods that corresponds to characteristics of
the dataset as shown in papers by Newman


# PredGraph
The way in which data about predgraph are stored has to be changed completely.
We were speaking about placing on the same edge both the real value
and the predicted value of trust, so that
for isntance computing the differences would be faster. Moreover, it
will work also if we try to predict only a fraction of the edges
(for example only 10% because the code is very slow).


# Trust metrics code
## check if the structure is consistend an refactor, for example there
is a better way of dealing with leave-one-out thing? Should it be a
different class such as TrustMetricEvaluation? Which methods should
the class TrustMetric export?
## correct code for trust metrics, try to make it more efficient,
write comments about them
## about advogato trust metric
### understand code of pymmetry for advogato trust metric
### understand how to use code of pymmetry
### integrate code for advogato from pymmetry into the trustlet
advogatoTM (both local and global) in a clever and correct way, so
that people who read the code
of trustlet don't have to know about certificates and how they are
used in pymmetry
## implement more trust metrics such as TidalTrust or AppleSeed (find
description in th relevant paper).


# Tables
As we have seen writing the paper, it is very important to be able to
easily and quickly generate the tables of results that you need, when
you need it.
This means being able to call methods such as

predGraph.getPredictionTable(rows=[array of trust
metrics],columns=[array of evaluation measures],multiplicity=array of
conditions on edges,precision=number_of_decimals)
that will generate for example
%% Condition=controversial_edges(0.3,0.5)     number of edges= 2367
                 |  fraction wrong predictions  |         MAE
 |        RMSE           |    Coverage   | #edgeswithprediction
AdvogatoLocal     |    0.343423                  |  0.11134342
 |  0.322343423          |     1.00      | 2367
AlwaysMaster      |    0.343423                  |  0.11134342
 |  0.322343423          |     0.50      | 1186
Ebay              |    0.887 555                 |  0.11134342
 |  0.322343423          |     1.00      | 2367
Moletrust3_0.4    |    0.343444                  |  0.11134342
 |  0.322343423          |     1.00      | 2367
%% Condition=every_edge()                     number of edges= 51344
                 |  fraction wrong predictions  |         MAE
 |        RMSE           |    Coverage   | #edgeswithprediction
AdvogatoLocal     |    0.343423                  |  0.11134342
 |  0.322343423          |     1.00      | 51344
AlwaysMaster      |    0.343423                  |  0.11134342
 |  0.322343423          |     0.84      | 50222
Ebay              |    0.887 555                 |  0.11134342
 |  0.322343423          |     1.00      | 51344
Moletrust3_0.4    |    0.343444                  |  0.11134342
 |  0.322343423          |     1.00      | 51344

OR

predGraph.getPredictionTable(rows=[array of conditions],columns=[array
of trust metrics],multiplicity=[array of evaluation
measures],precision=number_of_decimals)
that will generate for example
%% Evaluation measure=MAE
                             |  AdvogatoLocal               | Ebay
             |     Moletrust3_0.5
Controversial_edge(0.3,0.5)   |    0.343423                  |
0.11134342           |  0.322343423
every_edge                    |    0.343423                  |
0.11134342           |  0.322343423
edge_to_connected_node(30)    |    0.343423                  |
0.11134342           |  0.322343423
%% Evaluation measure=Coverage
                             |  AdvogatoLocal               | Ebay
             |     Moletrust3_0.5
Controversial_edge(0.3,0.5)   |    0.933423                  |
0.11134342           |  0.322343423
every_edge                    |    0.343423                  |
0.11134342           |  0.322343423
edge_to_connected_node(30)    |    0.343423                  |
0.11134342           |  0.322343423


Also think about different ways of exporting it (directly into a more
portable format?) (with fix width for columns? or with columns that
accomodate everything? as parameter, ...)
First, think about the methods and how we need them (and for what),
then implement them.


# Draft out at least the structure for the part of code that deals
with visualization of datasets (and of trust metrics on datasets).
Think about the structure of the classes, the methods and write some
example methods.
