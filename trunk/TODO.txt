
Here's a bunch of stuff to do.


Installing
==========

- fix setup.py to make "easy_install trustlet" work


Documentation
=============

Write a lot of documentation, especially for getting started with the
system after you download the code.

- epydoc
- pylint
- comments for every module, class, method and function
- more examples/*.py



Dataset module
==============

- functions for reading and writing GraphML, GMML and Pajek

- modularize the dataset class depending on whether a certain dataset
  is directed or undirected, weighted or unweighted, (sparse or not
  sparse)

- check powerlaw exponent, examples/powerlaw_test.py


- PredGraph
  - in case of only some edges predicted (ratio): add all original
    values and mark edges NOT_PREDICTED (find good name, wrt UNDEFINED)


- Trust metrics code
  - Check if structure is consistent and refactor, 
  - Is there a better way of dealing with leave-one-out thing?  Should
    it be a different class such as TrustMetricEvaluation?  Which
    methods should the class TrustMetric export?
  - Correct code for trust metrics, try to make it more efficient,
  - Write comments about them


Advogato
========

About the Advogato trust metric.

- understand code of pymmetry for advogato trust metric

- understand how to use code of pymmetry

- integrate code for advogato from pymmetry into the trustlet
  advogatoTM (both local and global) in a clever and correct way, so
  that people who read the code of trustlet don't have to know about
  certificates and how they are used in pymmetry

- implement more trust metrics such as TidalTrust or AppleSeed (find
  description in th relevant paper).


Visualization
=============

Draft out at least the structure for the part of code that deals with
visualization of datasets (and of trust metrics on datasets).  Think
about the structure of the classes, the methods and write some example
methods.



Tables
======

As we have seen writing the paper, it is very important to be able to
easily and quickly generate the tables of results that you need, when
you need it.  This means being able to call methods such as

predGraph.getPredictionTable(rows=[array of trust
metrics],columns=[array of evaluation measures],multiplicity=array of
conditions on edges,precision=number_of_decimals)
that will generate for example
%% Condition=controversial_edges(0.3,0.5)     number of edges= 2367
                 |  fraction wrong predictions  |         MAE
 |        RMSE           |    Coverage   | #edgeswithprediction
AdvogatoLocal     |    0.343423                  |  0.11134342
 |  0.322343423          |     1.00      | 2367
AlwaysMaster      |    0.343423                  |  0.11134342
 |  0.322343423          |     0.50      | 1186
Ebay              |    0.887 555                 |  0.11134342
 |  0.322343423          |     1.00      | 2367
Moletrust3_0.4    |    0.343444                  |  0.11134342
 |  0.322343423          |     1.00      | 2367
%% Condition=every_edge()                     number of edges= 51344
                 |  fraction wrong predictions  |         MAE
 |        RMSE           |    Coverage   | #edgeswithprediction
AdvogatoLocal     |    0.343423                  |  0.11134342
 |  0.322343423          |     1.00      | 51344
AlwaysMaster      |    0.343423                  |  0.11134342
 |  0.322343423          |     0.84      | 50222
Ebay              |    0.887 555                 |  0.11134342
 |  0.322343423          |     1.00      | 51344
Moletrust3_0.4    |    0.343444                  |  0.11134342
 |  0.322343423          |     1.00      | 51344

OR

predGraph.getPredictionTable(rows=[array of conditions],columns=[array
of trust metrics],multiplicity=[array of evaluation
measures],precision=number_of_decimals)
that will generate for example
%% Evaluation measure=MAE
                             |  AdvogatoLocal               | Ebay
             |     Moletrust3_0.5
Controversial_edge(0.3,0.5)   |    0.343423                  |
0.11134342           |  0.322343423
every_edge                    |    0.343423                  |
0.11134342           |  0.322343423
edge_to_connected_node(30)    |    0.343423                  |
0.11134342           |  0.322343423
%% Evaluation measure=Coverage
                             |  AdvogatoLocal               | Ebay
             |     Moletrust3_0.5
Controversial_edge(0.3,0.5)   |    0.933423                  |
0.11134342           |  0.322343423
every_edge                    |    0.343423                  |
0.11134342           |  0.322343423
edge_to_connected_node(30)    |    0.343423                  |
0.11134342           |  0.322343423


Also think about different ways of exporting it (directly into a more
portable format?) (with fix width for columns? or with columns that
accomodate everything? as parameter, ...)
First, think about the methods and how we need them (and for what),
then implement them.



